// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"sync"

	"github.com/nginxinc/nginx-service-mesh/pkg/k8s"
	"helm.sh/helm/v3/pkg/action"
	"k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	clientseta "k8s.io/kube-aggregator/pkg/client/clientset_generated/clientset"
	"k8s.io/metrics/pkg/client/clientset/versioned"
)

type FakeClient struct {
	APIExtensionClientSetStub        func() clientset.Interface
	aPIExtensionClientSetMutex       sync.RWMutex
	aPIExtensionClientSetArgsForCall []struct {
	}
	aPIExtensionClientSetReturns struct {
		result1 clientset.Interface
	}
	aPIExtensionClientSetReturnsOnCall map[int]struct {
		result1 clientset.Interface
	}
	APIRegistrationClientSetStub        func() clientseta.Interface
	aPIRegistrationClientSetMutex       sync.RWMutex
	aPIRegistrationClientSetArgsForCall []struct {
	}
	aPIRegistrationClientSetReturns struct {
		result1 clientseta.Interface
	}
	aPIRegistrationClientSetReturnsOnCall map[int]struct {
		result1 clientseta.Interface
	}
	ClientSetStub        func() kubernetes.Interface
	clientSetMutex       sync.RWMutex
	clientSetArgsForCall []struct {
	}
	clientSetReturns struct {
		result1 kubernetes.Interface
	}
	clientSetReturnsOnCall map[int]struct {
		result1 kubernetes.Interface
	}
	ConfigStub        func() *rest.Config
	configMutex       sync.RWMutex
	configArgsForCall []struct {
	}
	configReturns struct {
		result1 *rest.Config
	}
	configReturnsOnCall map[int]struct {
		result1 *rest.Config
	}
	DynamicClientSetStub        func() dynamic.Interface
	dynamicClientSetMutex       sync.RWMutex
	dynamicClientSetArgsForCall []struct {
	}
	dynamicClientSetReturns struct {
		result1 dynamic.Interface
	}
	dynamicClientSetReturnsOnCall map[int]struct {
		result1 dynamic.Interface
	}
	HelmActionStub        func(string) (*action.Configuration, error)
	helmActionMutex       sync.RWMutex
	helmActionArgsForCall []struct {
		arg1 string
	}
	helmActionReturns struct {
		result1 *action.Configuration
		result2 error
	}
	helmActionReturnsOnCall map[int]struct {
		result1 *action.Configuration
		result2 error
	}
	MeshExistsStub        func() (bool, error)
	meshExistsMutex       sync.RWMutex
	meshExistsArgsForCall []struct {
	}
	meshExistsReturns struct {
		result1 bool
		result2 error
	}
	meshExistsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	MetricsClientSetStub        func() versioned.Interface
	metricsClientSetMutex       sync.RWMutex
	metricsClientSetArgsForCall []struct {
	}
	metricsClientSetReturns struct {
		result1 versioned.Interface
	}
	metricsClientSetReturnsOnCall map[int]struct {
		result1 versioned.Interface
	}
	NamespaceStub        func() string
	namespaceMutex       sync.RWMutex
	namespaceArgsForCall []struct {
	}
	namespaceReturns struct {
		result1 string
	}
	namespaceReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) APIExtensionClientSet() clientset.Interface {
	fake.aPIExtensionClientSetMutex.Lock()
	ret, specificReturn := fake.aPIExtensionClientSetReturnsOnCall[len(fake.aPIExtensionClientSetArgsForCall)]
	fake.aPIExtensionClientSetArgsForCall = append(fake.aPIExtensionClientSetArgsForCall, struct {
	}{})
	stub := fake.APIExtensionClientSetStub
	fakeReturns := fake.aPIExtensionClientSetReturns
	fake.recordInvocation("APIExtensionClientSet", []interface{}{})
	fake.aPIExtensionClientSetMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) APIExtensionClientSetCallCount() int {
	fake.aPIExtensionClientSetMutex.RLock()
	defer fake.aPIExtensionClientSetMutex.RUnlock()
	return len(fake.aPIExtensionClientSetArgsForCall)
}

func (fake *FakeClient) APIExtensionClientSetCalls(stub func() clientset.Interface) {
	fake.aPIExtensionClientSetMutex.Lock()
	defer fake.aPIExtensionClientSetMutex.Unlock()
	fake.APIExtensionClientSetStub = stub
}

func (fake *FakeClient) APIExtensionClientSetReturns(result1 clientset.Interface) {
	fake.aPIExtensionClientSetMutex.Lock()
	defer fake.aPIExtensionClientSetMutex.Unlock()
	fake.APIExtensionClientSetStub = nil
	fake.aPIExtensionClientSetReturns = struct {
		result1 clientset.Interface
	}{result1}
}

func (fake *FakeClient) APIExtensionClientSetReturnsOnCall(i int, result1 clientset.Interface) {
	fake.aPIExtensionClientSetMutex.Lock()
	defer fake.aPIExtensionClientSetMutex.Unlock()
	fake.APIExtensionClientSetStub = nil
	if fake.aPIExtensionClientSetReturnsOnCall == nil {
		fake.aPIExtensionClientSetReturnsOnCall = make(map[int]struct {
			result1 clientset.Interface
		})
	}
	fake.aPIExtensionClientSetReturnsOnCall[i] = struct {
		result1 clientset.Interface
	}{result1}
}

func (fake *FakeClient) APIRegistrationClientSet() clientseta.Interface {
	fake.aPIRegistrationClientSetMutex.Lock()
	ret, specificReturn := fake.aPIRegistrationClientSetReturnsOnCall[len(fake.aPIRegistrationClientSetArgsForCall)]
	fake.aPIRegistrationClientSetArgsForCall = append(fake.aPIRegistrationClientSetArgsForCall, struct {
	}{})
	stub := fake.APIRegistrationClientSetStub
	fakeReturns := fake.aPIRegistrationClientSetReturns
	fake.recordInvocation("APIRegistrationClientSet", []interface{}{})
	fake.aPIRegistrationClientSetMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) APIRegistrationClientSetCallCount() int {
	fake.aPIRegistrationClientSetMutex.RLock()
	defer fake.aPIRegistrationClientSetMutex.RUnlock()
	return len(fake.aPIRegistrationClientSetArgsForCall)
}

func (fake *FakeClient) APIRegistrationClientSetCalls(stub func() clientseta.Interface) {
	fake.aPIRegistrationClientSetMutex.Lock()
	defer fake.aPIRegistrationClientSetMutex.Unlock()
	fake.APIRegistrationClientSetStub = stub
}

func (fake *FakeClient) APIRegistrationClientSetReturns(result1 clientseta.Interface) {
	fake.aPIRegistrationClientSetMutex.Lock()
	defer fake.aPIRegistrationClientSetMutex.Unlock()
	fake.APIRegistrationClientSetStub = nil
	fake.aPIRegistrationClientSetReturns = struct {
		result1 clientseta.Interface
	}{result1}
}

func (fake *FakeClient) APIRegistrationClientSetReturnsOnCall(i int, result1 clientseta.Interface) {
	fake.aPIRegistrationClientSetMutex.Lock()
	defer fake.aPIRegistrationClientSetMutex.Unlock()
	fake.APIRegistrationClientSetStub = nil
	if fake.aPIRegistrationClientSetReturnsOnCall == nil {
		fake.aPIRegistrationClientSetReturnsOnCall = make(map[int]struct {
			result1 clientseta.Interface
		})
	}
	fake.aPIRegistrationClientSetReturnsOnCall[i] = struct {
		result1 clientseta.Interface
	}{result1}
}

func (fake *FakeClient) ClientSet() kubernetes.Interface {
	fake.clientSetMutex.Lock()
	ret, specificReturn := fake.clientSetReturnsOnCall[len(fake.clientSetArgsForCall)]
	fake.clientSetArgsForCall = append(fake.clientSetArgsForCall, struct {
	}{})
	stub := fake.ClientSetStub
	fakeReturns := fake.clientSetReturns
	fake.recordInvocation("ClientSet", []interface{}{})
	fake.clientSetMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClientSetCallCount() int {
	fake.clientSetMutex.RLock()
	defer fake.clientSetMutex.RUnlock()
	return len(fake.clientSetArgsForCall)
}

func (fake *FakeClient) ClientSetCalls(stub func() kubernetes.Interface) {
	fake.clientSetMutex.Lock()
	defer fake.clientSetMutex.Unlock()
	fake.ClientSetStub = stub
}

func (fake *FakeClient) ClientSetReturns(result1 kubernetes.Interface) {
	fake.clientSetMutex.Lock()
	defer fake.clientSetMutex.Unlock()
	fake.ClientSetStub = nil
	fake.clientSetReturns = struct {
		result1 kubernetes.Interface
	}{result1}
}

func (fake *FakeClient) ClientSetReturnsOnCall(i int, result1 kubernetes.Interface) {
	fake.clientSetMutex.Lock()
	defer fake.clientSetMutex.Unlock()
	fake.ClientSetStub = nil
	if fake.clientSetReturnsOnCall == nil {
		fake.clientSetReturnsOnCall = make(map[int]struct {
			result1 kubernetes.Interface
		})
	}
	fake.clientSetReturnsOnCall[i] = struct {
		result1 kubernetes.Interface
	}{result1}
}

func (fake *FakeClient) Config() *rest.Config {
	fake.configMutex.Lock()
	ret, specificReturn := fake.configReturnsOnCall[len(fake.configArgsForCall)]
	fake.configArgsForCall = append(fake.configArgsForCall, struct {
	}{})
	stub := fake.ConfigStub
	fakeReturns := fake.configReturns
	fake.recordInvocation("Config", []interface{}{})
	fake.configMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ConfigCallCount() int {
	fake.configMutex.RLock()
	defer fake.configMutex.RUnlock()
	return len(fake.configArgsForCall)
}

func (fake *FakeClient) ConfigCalls(stub func() *rest.Config) {
	fake.configMutex.Lock()
	defer fake.configMutex.Unlock()
	fake.ConfigStub = stub
}

func (fake *FakeClient) ConfigReturns(result1 *rest.Config) {
	fake.configMutex.Lock()
	defer fake.configMutex.Unlock()
	fake.ConfigStub = nil
	fake.configReturns = struct {
		result1 *rest.Config
	}{result1}
}

func (fake *FakeClient) ConfigReturnsOnCall(i int, result1 *rest.Config) {
	fake.configMutex.Lock()
	defer fake.configMutex.Unlock()
	fake.ConfigStub = nil
	if fake.configReturnsOnCall == nil {
		fake.configReturnsOnCall = make(map[int]struct {
			result1 *rest.Config
		})
	}
	fake.configReturnsOnCall[i] = struct {
		result1 *rest.Config
	}{result1}
}

func (fake *FakeClient) DynamicClientSet() dynamic.Interface {
	fake.dynamicClientSetMutex.Lock()
	ret, specificReturn := fake.dynamicClientSetReturnsOnCall[len(fake.dynamicClientSetArgsForCall)]
	fake.dynamicClientSetArgsForCall = append(fake.dynamicClientSetArgsForCall, struct {
	}{})
	stub := fake.DynamicClientSetStub
	fakeReturns := fake.dynamicClientSetReturns
	fake.recordInvocation("DynamicClientSet", []interface{}{})
	fake.dynamicClientSetMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) DynamicClientSetCallCount() int {
	fake.dynamicClientSetMutex.RLock()
	defer fake.dynamicClientSetMutex.RUnlock()
	return len(fake.dynamicClientSetArgsForCall)
}

func (fake *FakeClient) DynamicClientSetCalls(stub func() dynamic.Interface) {
	fake.dynamicClientSetMutex.Lock()
	defer fake.dynamicClientSetMutex.Unlock()
	fake.DynamicClientSetStub = stub
}

func (fake *FakeClient) DynamicClientSetReturns(result1 dynamic.Interface) {
	fake.dynamicClientSetMutex.Lock()
	defer fake.dynamicClientSetMutex.Unlock()
	fake.DynamicClientSetStub = nil
	fake.dynamicClientSetReturns = struct {
		result1 dynamic.Interface
	}{result1}
}

func (fake *FakeClient) DynamicClientSetReturnsOnCall(i int, result1 dynamic.Interface) {
	fake.dynamicClientSetMutex.Lock()
	defer fake.dynamicClientSetMutex.Unlock()
	fake.DynamicClientSetStub = nil
	if fake.dynamicClientSetReturnsOnCall == nil {
		fake.dynamicClientSetReturnsOnCall = make(map[int]struct {
			result1 dynamic.Interface
		})
	}
	fake.dynamicClientSetReturnsOnCall[i] = struct {
		result1 dynamic.Interface
	}{result1}
}

func (fake *FakeClient) HelmAction(arg1 string) (*action.Configuration, error) {
	fake.helmActionMutex.Lock()
	ret, specificReturn := fake.helmActionReturnsOnCall[len(fake.helmActionArgsForCall)]
	fake.helmActionArgsForCall = append(fake.helmActionArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.HelmActionStub
	fakeReturns := fake.helmActionReturns
	fake.recordInvocation("HelmAction", []interface{}{arg1})
	fake.helmActionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) HelmActionCallCount() int {
	fake.helmActionMutex.RLock()
	defer fake.helmActionMutex.RUnlock()
	return len(fake.helmActionArgsForCall)
}

func (fake *FakeClient) HelmActionCalls(stub func(string) (*action.Configuration, error)) {
	fake.helmActionMutex.Lock()
	defer fake.helmActionMutex.Unlock()
	fake.HelmActionStub = stub
}

func (fake *FakeClient) HelmActionArgsForCall(i int) string {
	fake.helmActionMutex.RLock()
	defer fake.helmActionMutex.RUnlock()
	argsForCall := fake.helmActionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) HelmActionReturns(result1 *action.Configuration, result2 error) {
	fake.helmActionMutex.Lock()
	defer fake.helmActionMutex.Unlock()
	fake.HelmActionStub = nil
	fake.helmActionReturns = struct {
		result1 *action.Configuration
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) HelmActionReturnsOnCall(i int, result1 *action.Configuration, result2 error) {
	fake.helmActionMutex.Lock()
	defer fake.helmActionMutex.Unlock()
	fake.HelmActionStub = nil
	if fake.helmActionReturnsOnCall == nil {
		fake.helmActionReturnsOnCall = make(map[int]struct {
			result1 *action.Configuration
			result2 error
		})
	}
	fake.helmActionReturnsOnCall[i] = struct {
		result1 *action.Configuration
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) MeshExists() (bool, error) {
	fake.meshExistsMutex.Lock()
	ret, specificReturn := fake.meshExistsReturnsOnCall[len(fake.meshExistsArgsForCall)]
	fake.meshExistsArgsForCall = append(fake.meshExistsArgsForCall, struct {
	}{})
	stub := fake.MeshExistsStub
	fakeReturns := fake.meshExistsReturns
	fake.recordInvocation("MeshExists", []interface{}{})
	fake.meshExistsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) MeshExistsCallCount() int {
	fake.meshExistsMutex.RLock()
	defer fake.meshExistsMutex.RUnlock()
	return len(fake.meshExistsArgsForCall)
}

func (fake *FakeClient) MeshExistsCalls(stub func() (bool, error)) {
	fake.meshExistsMutex.Lock()
	defer fake.meshExistsMutex.Unlock()
	fake.MeshExistsStub = stub
}

func (fake *FakeClient) MeshExistsReturns(result1 bool, result2 error) {
	fake.meshExistsMutex.Lock()
	defer fake.meshExistsMutex.Unlock()
	fake.MeshExistsStub = nil
	fake.meshExistsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) MeshExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.meshExistsMutex.Lock()
	defer fake.meshExistsMutex.Unlock()
	fake.MeshExistsStub = nil
	if fake.meshExistsReturnsOnCall == nil {
		fake.meshExistsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.meshExistsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) MetricsClientSet() versioned.Interface {
	fake.metricsClientSetMutex.Lock()
	ret, specificReturn := fake.metricsClientSetReturnsOnCall[len(fake.metricsClientSetArgsForCall)]
	fake.metricsClientSetArgsForCall = append(fake.metricsClientSetArgsForCall, struct {
	}{})
	stub := fake.MetricsClientSetStub
	fakeReturns := fake.metricsClientSetReturns
	fake.recordInvocation("MetricsClientSet", []interface{}{})
	fake.metricsClientSetMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) MetricsClientSetCallCount() int {
	fake.metricsClientSetMutex.RLock()
	defer fake.metricsClientSetMutex.RUnlock()
	return len(fake.metricsClientSetArgsForCall)
}

func (fake *FakeClient) MetricsClientSetCalls(stub func() versioned.Interface) {
	fake.metricsClientSetMutex.Lock()
	defer fake.metricsClientSetMutex.Unlock()
	fake.MetricsClientSetStub = stub
}

func (fake *FakeClient) MetricsClientSetReturns(result1 versioned.Interface) {
	fake.metricsClientSetMutex.Lock()
	defer fake.metricsClientSetMutex.Unlock()
	fake.MetricsClientSetStub = nil
	fake.metricsClientSetReturns = struct {
		result1 versioned.Interface
	}{result1}
}

func (fake *FakeClient) MetricsClientSetReturnsOnCall(i int, result1 versioned.Interface) {
	fake.metricsClientSetMutex.Lock()
	defer fake.metricsClientSetMutex.Unlock()
	fake.MetricsClientSetStub = nil
	if fake.metricsClientSetReturnsOnCall == nil {
		fake.metricsClientSetReturnsOnCall = make(map[int]struct {
			result1 versioned.Interface
		})
	}
	fake.metricsClientSetReturnsOnCall[i] = struct {
		result1 versioned.Interface
	}{result1}
}

func (fake *FakeClient) Namespace() string {
	fake.namespaceMutex.Lock()
	ret, specificReturn := fake.namespaceReturnsOnCall[len(fake.namespaceArgsForCall)]
	fake.namespaceArgsForCall = append(fake.namespaceArgsForCall, struct {
	}{})
	stub := fake.NamespaceStub
	fakeReturns := fake.namespaceReturns
	fake.recordInvocation("Namespace", []interface{}{})
	fake.namespaceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) NamespaceCallCount() int {
	fake.namespaceMutex.RLock()
	defer fake.namespaceMutex.RUnlock()
	return len(fake.namespaceArgsForCall)
}

func (fake *FakeClient) NamespaceCalls(stub func() string) {
	fake.namespaceMutex.Lock()
	defer fake.namespaceMutex.Unlock()
	fake.NamespaceStub = stub
}

func (fake *FakeClient) NamespaceReturns(result1 string) {
	fake.namespaceMutex.Lock()
	defer fake.namespaceMutex.Unlock()
	fake.NamespaceStub = nil
	fake.namespaceReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeClient) NamespaceReturnsOnCall(i int, result1 string) {
	fake.namespaceMutex.Lock()
	defer fake.namespaceMutex.Unlock()
	fake.NamespaceStub = nil
	if fake.namespaceReturnsOnCall == nil {
		fake.namespaceReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.namespaceReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.aPIExtensionClientSetMutex.RLock()
	defer fake.aPIExtensionClientSetMutex.RUnlock()
	fake.aPIRegistrationClientSetMutex.RLock()
	defer fake.aPIRegistrationClientSetMutex.RUnlock()
	fake.clientSetMutex.RLock()
	defer fake.clientSetMutex.RUnlock()
	fake.configMutex.RLock()
	defer fake.configMutex.RUnlock()
	fake.dynamicClientSetMutex.RLock()
	defer fake.dynamicClientSetMutex.RUnlock()
	fake.helmActionMutex.RLock()
	defer fake.helmActionMutex.RUnlock()
	fake.meshExistsMutex.RLock()
	defer fake.meshExistsMutex.RUnlock()
	fake.metricsClientSetMutex.RLock()
	defer fake.metricsClientSetMutex.RUnlock()
	fake.namespaceMutex.RLock()
	defer fake.namespaceMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ k8s.Client = new(FakeClient)
