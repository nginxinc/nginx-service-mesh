// Package mesh provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package mesh

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// Defines values for MeshConfigAccessControlMode.
const (
	MeshConfigAccessControlModeAllow MeshConfigAccessControlMode = "allow"
	MeshConfigAccessControlModeDeny  MeshConfigAccessControlMode = "deny"
)

// Defines values for MeshConfigEnvironment.
const (
	Kubernetes MeshConfigEnvironment = "kubernetes"
	Openshift  MeshConfigEnvironment = "openshift"
)

// Defines values for MeshConfigLoadBalancingMethod.
const (
	MeshConfigLoadBalancingMethodLeastConn                  MeshConfigLoadBalancingMethod = "least_conn"
	MeshConfigLoadBalancingMethodLeastTime                  MeshConfigLoadBalancingMethod = "least_time"
	MeshConfigLoadBalancingMethodLeastTimeLastByte          MeshConfigLoadBalancingMethod = "least_time last_byte"
	MeshConfigLoadBalancingMethodLeastTimeLastByteInflight  MeshConfigLoadBalancingMethod = "least_time last_byte inflight"
	MeshConfigLoadBalancingMethodRandom                     MeshConfigLoadBalancingMethod = "random"
	MeshConfigLoadBalancingMethodRandomTwo                  MeshConfigLoadBalancingMethod = "random two"
	MeshConfigLoadBalancingMethodRandomTwoLeastConn         MeshConfigLoadBalancingMethod = "random two least_conn"
	MeshConfigLoadBalancingMethodRandomTwoLeastTime         MeshConfigLoadBalancingMethod = "random two least_time"
	MeshConfigLoadBalancingMethodRandomTwoLeastTimeLastByte MeshConfigLoadBalancingMethod = "random two least_time=last_byte"
	MeshConfigLoadBalancingMethodRoundRobin                 MeshConfigLoadBalancingMethod = "round_robin"
)

// Defines values for MeshConfigNginxErrorLogLevel.
const (
	MeshConfigNginxErrorLogLevelAlert  MeshConfigNginxErrorLogLevel = "alert"
	MeshConfigNginxErrorLogLevelCrit   MeshConfigNginxErrorLogLevel = "crit"
	MeshConfigNginxErrorLogLevelDebug  MeshConfigNginxErrorLogLevel = "debug"
	MeshConfigNginxErrorLogLevelEmerg  MeshConfigNginxErrorLogLevel = "emerg"
	MeshConfigNginxErrorLogLevelError  MeshConfigNginxErrorLogLevel = "error"
	MeshConfigNginxErrorLogLevelInfo   MeshConfigNginxErrorLogLevel = "info"
	MeshConfigNginxErrorLogLevelNotice MeshConfigNginxErrorLogLevel = "notice"
	MeshConfigNginxErrorLogLevelWarn   MeshConfigNginxErrorLogLevel = "warn"
)

// Defines values for MeshConfigNginxLogFormat.
const (
	MeshConfigNginxLogFormatDefault MeshConfigNginxLogFormat = "default"
	MeshConfigNginxLogFormatJson    MeshConfigNginxLogFormat = "json"
)

// Defines values for MtlsConfigCaKeyType.
const (
	EcP256  MtlsConfigCaKeyType = "ec-p256"
	EcP384  MtlsConfigCaKeyType = "ec-p384"
	Rsa2048 MtlsConfigCaKeyType = "rsa-2048"
	Rsa4096 MtlsConfigCaKeyType = "rsa-4096"
)

// Defines values for MtlsConfigMode.
const (
	Off        MtlsConfigMode = "off"
	Permissive MtlsConfigMode = "permissive"
	Strict     MtlsConfigMode = "strict"
)

// Defines values for PatchConfigFieldAccessControlMode.
const (
	PatchConfigFieldAccessControlModeAllow PatchConfigFieldAccessControlMode = "allow"
	PatchConfigFieldAccessControlModeDeny  PatchConfigFieldAccessControlMode = "deny"
)

// Defines values for PatchConfigFieldLoadBalancingMethod.
const (
	PatchConfigFieldLoadBalancingMethodLeastConn                  PatchConfigFieldLoadBalancingMethod = "least_conn"
	PatchConfigFieldLoadBalancingMethodLeastTime                  PatchConfigFieldLoadBalancingMethod = "least_time"
	PatchConfigFieldLoadBalancingMethodLeastTimeLastByte          PatchConfigFieldLoadBalancingMethod = "least_time last_byte"
	PatchConfigFieldLoadBalancingMethodLeastTimeLastByteInflight  PatchConfigFieldLoadBalancingMethod = "least_time last_byte inflight"
	PatchConfigFieldLoadBalancingMethodRandom                     PatchConfigFieldLoadBalancingMethod = "random"
	PatchConfigFieldLoadBalancingMethodRandomTwo                  PatchConfigFieldLoadBalancingMethod = "random two"
	PatchConfigFieldLoadBalancingMethodRandomTwoLeastConn         PatchConfigFieldLoadBalancingMethod = "random two least_conn"
	PatchConfigFieldLoadBalancingMethodRandomTwoLeastTime         PatchConfigFieldLoadBalancingMethod = "random two least_time"
	PatchConfigFieldLoadBalancingMethodRandomTwoLeastTimeLastByte PatchConfigFieldLoadBalancingMethod = "random two least_time=last_byte"
	PatchConfigFieldLoadBalancingMethodRoundRobin                 PatchConfigFieldLoadBalancingMethod = "round_robin"
)

// Defines values for PatchConfigFieldNginxErrorLogLevel.
const (
	PatchConfigFieldNginxErrorLogLevelAlert  PatchConfigFieldNginxErrorLogLevel = "alert"
	PatchConfigFieldNginxErrorLogLevelCrit   PatchConfigFieldNginxErrorLogLevel = "crit"
	PatchConfigFieldNginxErrorLogLevelDebug  PatchConfigFieldNginxErrorLogLevel = "debug"
	PatchConfigFieldNginxErrorLogLevelEmerg  PatchConfigFieldNginxErrorLogLevel = "emerg"
	PatchConfigFieldNginxErrorLogLevelError  PatchConfigFieldNginxErrorLogLevel = "error"
	PatchConfigFieldNginxErrorLogLevelInfo   PatchConfigFieldNginxErrorLogLevel = "info"
	PatchConfigFieldNginxErrorLogLevelNotice PatchConfigFieldNginxErrorLogLevel = "notice"
	PatchConfigFieldNginxErrorLogLevelWarn   PatchConfigFieldNginxErrorLogLevel = "warn"
)

// Defines values for PatchConfigFieldNginxLogFormat.
const (
	PatchConfigFieldNginxLogFormatDefault PatchConfigFieldNginxLogFormat = "default"
	PatchConfigFieldNginxLogFormatJson    PatchConfigFieldNginxLogFormat = "json"
)

// Defines values for PatchConfigOp.
const (
	Add     PatchConfigOp = "add"
	Remove  PatchConfigOp = "remove"
	Replace PatchConfigOp = "replace"
)

// APIConfig The configuration of the NGINX Service Mesh API.
type APIConfig struct {
	// Address The Kubernetes DNS name of the NGINX Service Mesh API.
	Address string `json:"address"`

	// ContainerPort The container port of the NGINX Service Mesh API.
	ContainerPort int `json:"containerPort"`

	// Port The port of the NGINX Service Mesh API.
	Port int `json:"port"`
}

// ErrorDetail defines model for ErrorDetail.
type ErrorDetail struct {
	// Description A detailed error message returned by the server.
	//
	// These messages contain the following information, where applicable:
	//
	// - What happened.
	// - Why it happened.
	// - What the consequences are (if any).
	// - Recommended action to take to resolve the issue.
	Description string `json:"description"`
}

// ErrorModel defines model for ErrorModel.
type ErrorModel struct {
	// Code A numeric error code that can be used to identify errors for support purposes.
	Code    int            `json:"code"`
	Details *[]ErrorDetail `json:"details,omitempty"`

	// Message A human-readable message, in English, that describes the error.
	Message string `json:"message"`
}

// ExportersConfig The configuration of exporters to send telemetry data to.
type ExportersConfig struct {
	// Otlp The configuration for an OTLP gRPC exporter.
	Otlp *OtlpExporterConfig `json:"otlp,omitempty"`
}

// Image A container image, comprised of an image name and image tag.
type Image struct {
	// Image The tag of the image.
	Image string `json:"image"`

	// Name The name of the image.
	Name string `json:"name"`
}

// MeshConfig Holds combined configuration required to run the NGINX Service Mesh control plane
// and the data plane.
type MeshConfig struct {
	// AccessControlMode The access control mode of NGINX Service Mesh.
	AccessControlMode MeshConfigAccessControlMode `json:"accessControlMode"`

	// Api The configuration of the NGINX Service Mesh API.
	Api APIConfig `json:"api"`

	// AutoInjectorPort The port that the automatic injection webhook binds to.
	AutoInjectorPort int `json:"autoInjectorPort"`

	// ClientMaxBodySize The maximum allowed size of the client request body.
	ClientMaxBodySize string `json:"clientMaxBodySize"`

	// EnabledNamespaces A list of namespaces where automatic injection is enabled. To set this field, the isAutoInjectEnabled field must be false.
	EnabledNamespaces *[]string `json:"enabledNamespaces,omitempty"`

	// Environment The environment that the NGINX Service Mesh control plane is installed in.
	Environment MeshConfigEnvironment `json:"environment"`

	// IsAutoInjectEnabled Whether or not automatic injection of the NGINX Service Mesh sidecar is enabled globally.
	IsAutoInjectEnabled *bool `json:"isAutoInjectEnabled,omitempty"`

	// IsUDPEnabled Enable UDP traffic proxying.
	IsUDPEnabled bool `json:"isUDPEnabled"`

	// LoadBalancingMethod The global load balancing method for Services in NGINX Service Mesh. This value can be overridden on a per-Service basis with a Service annotation.
	LoadBalancingMethod MeshConfigLoadBalancingMethod `json:"loadBalancingMethod"`

	// Mtls The configuration for mTLS.
	Mtls MtlsConfig `json:"mtls"`

	// Namespace The namespace where the NGINX Service Mesh control plane is installed.
	Namespace string `json:"namespace"`

	// NginxErrorLogLevel The error log level of the NGINX Service Mesh sidecar proxies.
	NginxErrorLogLevel MeshConfigNginxErrorLogLevel `json:"nginxErrorLogLevel"`

	// NginxLogFormat The log format of the NGINX Service Mesh sidecar proxies.
	NginxLogFormat MeshConfigNginxLogFormat `json:"nginxLogFormat"`

	// PrometheusAddress The address of the Prometheus server deployment.
	PrometheusAddress string `json:"prometheusAddress"`

	// Proxy The configuration of the NGINX Service Mesh sidecar proxies.
	Proxy ProxyConfig `json:"proxy"`

	// RegistryKeyName The name of the registry key that is used to pull the NGINX Service Mesh docker images.
	RegistryKeyName string `json:"registryKeyName"`

	// SidecarImage A container image, comprised of an image name and image tag.
	SidecarImage Image `json:"sidecarImage"`

	// SidecarInitImage A container image, comprised of an image name and image tag.
	SidecarInitImage Image `json:"sidecarInitImage"`

	// Telemetry The configuration for telemetry.
	Telemetry TelemetryConfig `json:"telemetry"`

	// TrustDomain The trust domain of the NGINX Service Mesh.
	TrustDomain string `json:"trustDomain"`
}

// MeshConfigAccessControlMode The access control mode of NGINX Service Mesh.
type MeshConfigAccessControlMode string

// MeshConfigEnvironment The environment that the NGINX Service Mesh control plane is installed in.
type MeshConfigEnvironment string

// MeshConfigLoadBalancingMethod The global load balancing method for Services in NGINX Service Mesh. This value can be overridden on a per-Service basis with a Service annotation.
type MeshConfigLoadBalancingMethod string

// MeshConfigNginxErrorLogLevel The error log level of the NGINX Service Mesh sidecar proxies.
type MeshConfigNginxErrorLogLevel string

// MeshConfigNginxLogFormat The log format of the NGINX Service Mesh sidecar proxies.
type MeshConfigNginxLogFormat string

// MtlsConfig The configuration for mTLS.
type MtlsConfig struct {
	// CaKeyType The key type used for the SPIRE Server CA.
	CaKeyType *MtlsConfigCaKeyType `json:"caKeyType,omitempty"`

	// CaTTL The CA/signing key TTL in hours(h). Min value 24h. Max value 999999h.
	CaTTL *string `json:"caTTL,omitempty"`

	// Mode The mTLS mode of NGINX Service Mesh.
	Mode *MtlsConfigMode `json:"mode,omitempty"`

	// SvidTTL The TTL of certificates issued to workloads in hours(h) or minutes(m). Max value is 999999.
	SvidTTL *string `json:"svidTTL,omitempty"`
}

// MtlsConfigCaKeyType The key type used for the SPIRE Server CA.
type MtlsConfigCaKeyType string

// MtlsConfigMode The mTLS mode of NGINX Service Mesh.
type MtlsConfigMode string

// OtlpExporterConfig The configuration for an OTLP gRPC exporter.
type OtlpExporterConfig struct {
	// Host The host of the OpenTelemetry gRPC exporter to connect to.
	Host string `json:"host"`

	// Port The port of the OpenTelemetry gRPC exporter to connect to.
	Port int `json:"port"`
}

// PatchConfig The configuration object that holds the updates to be made to the NGINX Service Mesh configuration.
type PatchConfig struct {
	Field struct {
		// AccessControlMode The access control mode of NGINX Service Mesh.
		AccessControlMode *PatchConfigFieldAccessControlMode `json:"accessControlMode,omitempty"`

		// ClientMaxBodySize The maximum allowed size of the client request body.
		ClientMaxBodySize *string `json:"clientMaxBodySize,omitempty"`

		// EnabledNamespaces A list of namespaces where automatic injection is enabled. To set this field, the isAutoInjectEnabled field must be false.
		EnabledNamespaces *[]string `json:"enabledNamespaces,omitempty"`

		// IsAutoInjectEnabled Whether or not automatic injection of the NGINX Service Mesh sidecar is enabled. This value can be overridden on a per-Pod basis with a Pod annotation.
		IsAutoInjectEnabled *bool `json:"isAutoInjectEnabled,omitempty"`

		// LoadBalancingMethod The global load balancing method for Services in NGINX Service Mesh. This value can be overridden on a per-Service basis with a Service annotation.
		LoadBalancingMethod *PatchConfigFieldLoadBalancingMethod `json:"loadBalancingMethod,omitempty"`

		// Mtls The configuration for mTLS.
		Mtls *MtlsConfig `json:"mtls,omitempty"`

		// NginxErrorLogLevel The error log level of the NGINX Service Mesh sidecar proxies.
		NginxErrorLogLevel *PatchConfigFieldNginxErrorLogLevel `json:"nginxErrorLogLevel,omitempty"`

		// NginxLogFormat The log format of the NGINX Service Mesh sidecar proxies.
		NginxLogFormat *PatchConfigFieldNginxLogFormat `json:"nginxLogFormat,omitempty"`

		// PrometheusAddress The address of the Prometheus server. Must be reachable from the Kubernetes cluster that NGINX Service Mesh is installed in.
		PrometheusAddress *string `json:"prometheusAddress,omitempty"`

		// Telemetry The configuration for telemetry.
		Telemetry *TelemetryConfig `json:"telemetry,omitempty"`
	} `json:"field"`

	// Op The type of operation to be performed on the NGINX Service Mesh configuration. Values in the NGINX Service Mesh configuration can be added, removed, or replaced.
	Op PatchConfigOp `json:"op"`
}

// PatchConfigFieldAccessControlMode The access control mode of NGINX Service Mesh.
type PatchConfigFieldAccessControlMode string

// PatchConfigFieldLoadBalancingMethod The global load balancing method for Services in NGINX Service Mesh. This value can be overridden on a per-Service basis with a Service annotation.
type PatchConfigFieldLoadBalancingMethod string

// PatchConfigFieldNginxErrorLogLevel The error log level of the NGINX Service Mesh sidecar proxies.
type PatchConfigFieldNginxErrorLogLevel string

// PatchConfigFieldNginxLogFormat The log format of the NGINX Service Mesh sidecar proxies.
type PatchConfigFieldNginxLogFormat string

// PatchConfigOp The type of operation to be performed on the NGINX Service Mesh configuration. Values in the NGINX Service Mesh configuration can be added, removed, or replaced.
type PatchConfigOp string

// PortsConfig The ports that the NGINX Service Mesh sidecar proxies listen on.
type PortsConfig struct {
	// Incoming The incoming HTTP port.
	Incoming int `json:"incoming"`

	// IncomingGrpc The incoming gRPC port.
	IncomingGrpc int `json:"incomingGrpc"`

	// IncomingGrpcPermissive The incoming gRPC port when the mTLS mode of the sidecar proxy is set to permissive.
	IncomingGrpcPermissive int `json:"incomingGrpcPermissive"`

	// IncomingNotInKeyval The incoming port that handles requests from Services not in the NGINX Service Mesh.
	IncomingNotInKeyval int `json:"incomingNotInKeyval"`

	// IncomingPermissive The incoming HTTP port when the mTLS mode of the sidecar proxy is set to permissive.
	IncomingPermissive int `json:"incomingPermissive"`

	// IncomingRedirect The incoming redirect port. This port redirects requests to another port on the sidecar proxy based on the protocol of the request.
	IncomingRedirect int `json:"incomingRedirect"`

	// IncomingTcp The incoming TCP port.
	IncomingTcp int `json:"incomingTcp"`

	// IncomingTcpDeny The incoming TCP deny port. This port denies TCP traffic if it is not a part of NGINX Service Mesh or if the access to the sidecar is not allowed.
	IncomingTcpDeny int `json:"incomingTcpDeny"`

	// IncomingTcpPermissive The incoming TCP port when the mTLS mode of the sidecar proxy is set to perissive.
	IncomingTcpPermissive int `json:"incomingTcpPermissive"`

	// IncomingUdp The incoming UDP port.
	IncomingUdp int `json:"incomingUdp"`

	// Metrics The Prometheus metrics port.
	Metrics int `json:"metrics"`

	// Outgoing The outgoing HTTP port.
	Outgoing int `json:"outgoing"`

	// OutgoingDefaultEgress The outgoing traffic port for egress traffic when the NGINX Plus Ingress Controller is deployed as an egress controller.
	OutgoingDefaultEgress int `json:"outgoingDefaultEgress"`

	// OutgoingGrpc The outgoing gRPC port.
	OutgoingGrpc int `json:"outgoingGrpc"`

	// OutgoingNotInKeyval The outgoing port for destinations that are not a part of NGINX Service Mesh.
	OutgoingNotInKeyval int `json:"outgoingNotInKeyval"`

	// OutgoingRedirect The outgoing redirect port. This port redirects requests to another port on the sidecar proxy based on the protocol of the request.
	OutgoingRedirect int `json:"outgoingRedirect"`

	// OutgoingTcp The outgoing TCP port.
	OutgoingTcp int `json:"outgoingTcp"`

	// OutgoingUdp The outgoing UDP port.
	OutgoingUdp int `json:"outgoingUdp"`

	// PlusApi The port for the NGINX Plus API. This API is not accessible outside of the NGINX Service Mesh sidecar container.
	PlusApi int `json:"plusApi"`

	// RedirectHealthPort This port redirects HTTP health probes to the application container.
	RedirectHealthPort int `json:"redirectHealthPort"`

	// RedirectHealthPortHTTPS This port redirects HTTPS health probes to the application container.
	RedirectHealthPortHTTPS int `json:"redirectHealthPortHTTPS"`
}

// ProxyConfig The configuration of the NGINX Service Mesh sidecar proxies.
type ProxyConfig struct {
	// Ports The ports that the NGINX Service Mesh sidecar proxies listen on.
	Ports PortsConfig `json:"ports"`

	// Transparent Whether or not the NGINX Service Mesh sidecar proxies are running in transparent mode. Transparent mode means that the sidecar proxies are passing the traffic through to the destination without applying any rules to the traffic.
	Transparent bool `json:"transparent"`
}

// Service The configuration of a Service resource in NGINX Service Mesh.
type Service struct {
	// Addresses The IP addresses of the Endpoints of the Kubernetes Service.
	Addresses []string `json:"addresses"`

	// Name The Kubernetes Service name.
	Name string `json:"name"`

	// Namespace The namespace of the Kubernetes Service.
	Namespace *string `json:"namespace,omitempty"`

	// Ports The ports of the Kubernetes Service.
	Ports []ServicePort `json:"ports"`

	// ServiceIP The IP address of the Kubernetes Service.
	ServiceIP *string `json:"serviceIP,omitempty"`
}

// ServicePort A representation of a Service Port in NGINX Service Mesh. Contains the port number and the protocol.
type ServicePort struct {
	// Port The port number.
	Port int32 `json:"port"`

	// Protocol The protocol of the traffic.
	Protocol string `json:"protocol"`
}

// TelemetryConfig The configuration for telemetry.
type TelemetryConfig struct {
	// Exporters The configuration of exporters to send telemetry data to.
	Exporters *ExportersConfig `json:"exporters,omitempty"`

	// SamplerRatio The percentage of traces that are processed and exported to the telemetry backend.
	SamplerRatio *float32 `json:"samplerRatio,omitempty"`
}

// BadRequest defines model for BadRequest.
type BadRequest = ErrorModel

// Forbidden defines model for Forbidden.
type Forbidden = ErrorModel

// InternalServerError defines model for InternalServerError.
type InternalServerError = ErrorModel

// Unauthorized defines model for Unauthorized.
type Unauthorized = ErrorModel

// PatchConfigJSONBody defines parameters for PatchConfig.
type PatchConfigJSONBody struct {
	union json.RawMessage
}

// PatchConfigJSONBody1 defines parameters for PatchConfig.
type PatchConfigJSONBody1 = []PatchConfig

// PatchConfigJSONRequestBody defines body for PatchConfig for application/json ContentType.
type PatchConfigJSONRequestBody PatchConfigJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetConfig request
	GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchConfig request with any body
	PatchConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchConfig(ctx context.Context, body PatchConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServices request
	GetServices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchConfig(ctx context.Context, body PatchConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchConfigRequest calls the generic PatchConfig builder with application/json body
func NewPatchConfigRequest(server string, body PatchConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewPatchConfigRequestWithBody generates requests for PatchConfig with any type of body
func NewPatchConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServicesRequest generates requests for GetServices
func NewGetServicesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetConfig request
	GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error)

	// PatchConfig request with any body
	PatchConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchConfigResponse, error)

	PatchConfigWithResponse(ctx context.Context, body PatchConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchConfigResponse, error)

	// GetServices request
	GetServicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServicesResponse, error)
}

type GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MeshConfig
	JSON401      *ErrorModel
	JSON403      *ErrorModel
	JSON500      *ErrorModel
}

// Status returns HTTPResponse.Status
func (r GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MeshConfig
	JSON400      *ErrorModel
	JSON401      *ErrorModel
	JSON403      *ErrorModel
}

// Status returns HTTPResponse.Status
func (r PatchConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Service
	JSON401      *ErrorModel
	JSON403      *ErrorModel
	JSON500      *ErrorModel
}

// Status returns HTTPResponse.Status
func (r GetServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetConfigWithResponse request returning *GetConfigResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error) {
	rsp, err := c.GetConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigResponse(rsp)
}

// PatchConfigWithBodyWithResponse request with arbitrary body returning *PatchConfigResponse
func (c *ClientWithResponses) PatchConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchConfigResponse, error) {
	rsp, err := c.PatchConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchConfigResponse(rsp)
}

func (c *ClientWithResponses) PatchConfigWithResponse(ctx context.Context, body PatchConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchConfigResponse, error) {
	rsp, err := c.PatchConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchConfigResponse(rsp)
}

// GetServicesWithResponse request returning *GetServicesResponse
func (c *ClientWithResponses) GetServicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServicesResponse, error) {
	rsp, err := c.GetServices(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesResponse(rsp)
}

// ParseGetConfigResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigResponse(rsp *http.Response) (*GetConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeshConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchConfigResponse parses an HTTP response from a PatchConfigWithResponse call
func ParsePatchConfigResponse(rsp *http.Response) (*PatchConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeshConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetServicesResponse parses an HTTP response from a GetServicesWithResponse call
func ParseGetServicesResponse(rsp *http.Response) (*GetServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get NGINX Service Mesh configuration
	// (GET /config)
	GetConfig(ctx echo.Context) error
	// Update NGINX Service Mesh Configuration
	// (PATCH /config)
	PatchConfig(ctx echo.Context) error
	// List all Services
	// (GET /services)
	GetServices(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetConfig(ctx)
	return err
}

// PatchConfig converts echo context to params.
func (w *ServerInterfaceWrapper) PatchConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchConfig(ctx)
	return err
}

// GetServices converts echo context to params.
func (w *ServerInterfaceWrapper) GetServices(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetServices(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/config", wrapper.GetConfig)
	router.PATCH(baseURL+"/config", wrapper.PatchConfig)
	router.GET(baseURL+"/services", wrapper.GetServices)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"XgiDVqllo5pM7PuH/w8AAP//ujSIv2RUAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
